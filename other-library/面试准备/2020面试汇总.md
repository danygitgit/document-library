[面试总结](https://github.com/danygitgit/document-library)
===
> create by **db** on **2020-5-14 22:37:37**   
> Recently revised in **2020-5-14 22:37:42**
> 
**闲时要有吃紧的心思，忙时要有悠闲的趣味**

# <a name="chapter-1" id="chapter-1">前言</a>

&emsp;2020面试历程，在这里总结一下

# <a name="chapter-2" id="chapter-2">正文</a>

## 字节跳动一面

### 1.	三栏布局的实现及优缺点
<!-- （1）	圣杯布局
（2）	双飞翼布局 -->
| 布局方案     |实现| 优点                            | 缺点                                                                                             |
| ------------ | ---| ------------------------------- | ------------------------------------------------------------------------------------------------ |
| Float布局    |左右中三列，左列左浮动，右列右浮动，中间列设置左右margin| 比较简单，兼容性也比较好        | 浮动元素脱离文档流，使用的时候只需要注意一定要清除浮动。                                         |
| Position布局 |左中右三列（无顺序），根据定位属性去直接设置各个子元素位置| 快捷，设置很方便                | 元素脱离了文档流，后代元素也脱离了文档流，高度未知的时候，会有问题，有效性和可使用性比较差       |
| Table布局    |左中右三列，父元素display: table;子元素display: table-cell;居中子元素不设宽度| 使用起来方便,兼容性也不存在问题 | ①无法设置栏边距；②对seo不友好；③当其中一个单元格高度超出的时候，两侧的单元格也是会跟着一起变高的 |
| Flex布局     |左中右三列，父元素display: flex;两侧元素设宽；居中子元素flex: 1;| 比较完美                        | 存在IE上兼容性问题，只能支持到IE9以上                                                            |
| Grid布局     |左中右三列，父元素display: grid;利用网格实现 |最强大和最简单                  | 兼容性不好，IE10+上支持，而且也仅支持部分属性                                                                                       |


### 2.	文字单行显示/三行显示
> 单行文本溢出隐藏变为...
```css
 p {
    /* 隐藏元素溢出内容 */
    overflow: hidden;
    /* 单行显示 */
    white-space: nowrap;
    /* 溢出显示省略号 */
    text-overflow: ellipsis;
  }
  ```

  > 多行文本溢出隐藏变为...
```css
  p {
    overflow: hidden;
    /* 将对象作为弹性伸缩盒子模型显示 。 */
    display: -webkit-box;
    /* 限制在一个块元素显示的文本的行数，即行数设置 */
    -webkit-line-clamp: 3;
    /* 规定框从上向下垂直排列子元素 */
    -webkit-box-orient: vertical;
  }
  ```

### 3.	重绘和回流

  **回流**：当render tree中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。这就称为回流(其实我觉得叫重新布局更简单明了些)。每个页面至少需要一次回流，就是在页面第一次加载的时候。

  **重绘**:当render tree中的一些元素需要更新属性，这些属性只是影响元素的外观，风格，而不会影响布局的，比如background-color。则就叫称为重绘。

**区别**
  -  回流必将引起重绘，而重绘不一定会引起回流。比如：只有颜色改变的时候就只会发生重绘而不会引起回流
  -  当页面布局和几何属性改变时就需要回流
  比如：添加或者删除可见的DOM元素，元素位置改变，元素尺寸改变——边距、填充、边框、宽度和高度，内容改变

  - 回流往往伴随着布局的变化，代价较大：

  - 重绘只是样式的变化，结构不会变化：

### 4.	手写斐波那契数列及其优化

**什么是斐波那契数列**： 斐波那契数列（Fibonacci sequence），又称黄金分割数列、因数学家列昂纳多·斐波那契（Leonardoda Fibonacci）以兔子繁殖为例子而引入，故又称为“兔子数列”，指的是这样一个数列：1、1、2、3、5、8、13、21、34、……在数学上，斐波纳契数列以如下被以递归的方法定义：F(0)=1，F(1)=1, F(n)=F(n-1)+F(n-2)（n>2，n∈N*）, 这个数列从第3项开始，每一项都等于前两项之和

```js
function Fibonacci (n) {
  if ( n <= 1 ) {return 1};
  return Fibonacci(n - 1) + Fibonacci(n - 2);
}
```
这个方法算是代码最少也容易理解，但是当n较大时很快产生栈溢出，引发原因是“调用帧”过多，出现浏览器假死现象。详情参阅[函数扩展之尾调用优化——阮一峰](https://es6.ruanyifeng.com/#docs/function)。

2. 递归（优化版）
```js
function Fibonacci2 (n , ac1 = 1 , ac2 = 1) {
  if( n <= 1 ) {return ac2};
  return Fibonacci2 (n - 1, ac2, ac1 + ac2);
}
```
此方式是函数尾调用优化之后的写法（默认参数ES6及以后版本支持，ES5请使用常规默认值写法），理解上稍微复杂，但是不会发生栈溢出，推荐使用。

3. 普通循环版

```js
function Fibonacci3(n) {
  if (n===1 || n===2) {
        return 1;
    }
    var n1 = 1, n2 = 1, sum;
    for (let i = 2; i < n; i++) {
        sum = n1 + n2
        n1 = n2
        n2 = sum
    }
    return sum
}
```
循环版本最好理解，就是给初始值，然后不断的累加即可

4. 解构赋值版
```js
var Fibonacci4 = function (n) {
  if (n===1 || n===2) {
        return 1;
    }
    let n1 = 1; n2 = 1;
    for (let i = 2; i < n; i++) {
        [n1, n2] = [n2, n1 + n2]
    }
    return n2
}
```
循环版本最好理解，就是给初始值，然后不断的累加即可(用了解构赋值，代码更简洁)。


### 5. 查看代码输出，什么是宏任务和微任务，都包括哪些？
   
```js
  setTimeout(function() {
  console.log(1)
}, 0);
new Promise(function executor(resolve) {
  console.log(2);
  for( var i=0 ; i<10000 ; i++ ) {
    i == 9999 && resolve();
  }
  console.log(3);
}).then(function() {
  console.log(4);
});
console.log(5);
```
输出：
```
2
3
5
4
1
```




**宏任务**
 
|#|	浏览器|	Node|
|---|---|---|
|setTimeout|	√|	√|
|setInterval|	√|	√|
|setImmediate|	x|	√|
|requestAnimationFrame|	√|	x|
 

**微任务**

|#	|浏览器	|Node|
|---|---|---|
|process.nextTick	|x	|√|
|MutationObserver|√	|x|
|Promise.then catchfinally Async/Await	|√	|√|

**执行机制**：

<!-- 1. 执行一个宏任务（栈中没有就从事件队列中获取）

2. 执行过程中如果遇到微任务，就将它添加到微任务的任务队列中

3. 宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）

4. 当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染

5. 渲染完毕后，JS引擎线程继续，开始下一个宏任务（从宏任务队列中获取） -->

1. 先执行主线程
2. 遇到宏队列（macrotask）放到宏队列（macrotask）
3. 遇到微队列（microtask）放到微队列（microtask）
4. 主线程执行完毕
5. 执行微队列（microtask），微队列（microtask）执行完毕
6. 执行一次宏队列（macrotask）中的一个任务，执行完毕
7. 执行微队列（microtask），执行完毕
8. 依次循环。。。


### 6.	编写javascript深度克隆函数deepClone

```js
// 深拷贝
/**
 * 深拷贝对象，可以正确序列化日期
 * @param {*} obj
 */
export const DEEP_CLONE = function (obj) {
  let objClone = Array.isArray(obj) ? [] : {}
  if (obj && typeof obj === 'object') {
    for (let key in obj) {
      if (obj.hasOwnProperty(key)) {
        // 判断ojb子元素是否为对象，如果是，递归复制
        if (obj[key] && typeof obj[key] === 'object') {
          // 深拷贝日期类型
          if (obj[key] instanceof Date) {
            objClone[key] = new Date(obj[key].valueOf())
            // console.log('deepClone', objClone[key])
          } else {
            objClone[key] = DEEP_CLONE(obj[key])
          }
        } else {
          // 如果不是，简单复制
          objClone[key] = obj[key]
        }
      }
    }
  }
  return objClone
}

```
### 7.	vue路由的两种模式

#### **hash**

**原理**
- 早期的前端路由的实现就是基于location.hash来实现的，location.hash的值就是URL中#后面的内容
其实现原理就是监听#后面的内容来发起Ajax请求来进行局部更新，而不需要刷新整个页面。
- 使用hashchange事件来监听 URL 的变化，以下这几种情况改变 URL 都会触发 hashchange 事件：浏览器前进后退改变 URL、a标签改变 URL、window.location改变URL。

**优点**
> 兼容低版本浏览器，Angular1.x和Vue默认使用的就是hash路由
只有#符号之前的内容才会包含在请求中被发送到后端，也就是说就算后端没有对路由全覆盖，但是不会返回404错误
hash值的改变，都会在浏览器的访问历史中增加一个记录，所以可以通过浏览器的回退、前进按钮控制hash的切换
会覆盖锚点定位元素的功能

**缺点**

> 不太美观，#后面传输的数据复杂的话会出现问题


#### **history**

**原理**

- history 提供了 pushState 和 replaceState 两个方法来记录路由状态，这两个方法改变 URL 不会引起页面刷新
- history 提供类似 hashchange 事件的 popstate 事件，但 popstate 事件有些不同：通过浏览器前进后退改变 URL 时会触发 popstate 事件，通过pushState/replaceState或a标签改变 URL 不会触发 popstate 事件。好在我们可以拦截 pushState/replaceState的调用和a标签的点击事件来检测 URL 变化，所以监听 URL 变化可以实现，只是没有 hashchange 那么方便。
- pushState(state, title, url) 和 replaceState(state, title, url)都可以接受三个相同的参数。

**优点**

> 使用简单，比较美观

> pushState()设置新的URL可以是任意与当前URL同源的URL，而hash只能改变#后面的内容，因此只能设置与当前URL同文档的URL

> pushState()设置的URL与当前URL一模一样时也会被添加到历史记录栈中，而hash#后面的内容必须被修改才会被添加到新的记录栈中

> pushState()可以通过stateObject参数添加任意类型的数据到记录中，而hash只能添加短字符串
> pushState()可额外设置title属性供后续使用

**缺点**

> 前端的URL必须和向发送请求后端URL保持一致，否则会报404错误

>由于History API的缘故，低版本浏览器有兼容行问题

**两种不同使用场景**

- 从上文可见，hash模式下url会带有#，当你希望url更优雅时，可以使用history模式。
- 当使用history模式时，需要注意在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面。
- 当需要兼容低版本的浏览器时，建议使用hash模式。
- 当需要添加任意类型数据到记录时，可以使用history模式。


### 8. 编写js事件绑定函数

```js
  const Event = {
    on() {} // 绑定
    off() {} // 解绑
    trigger() {} // 触发事件
};
```

```js
class Event {
  constructor() {
    // 为了查找迅速使用了对象
    this._cache = {};
  }
  // 绑定事件
  on(eventName, callback) {
    /* 为了查找方便和节省空间, 把同一类型事件放到数组中
     *  因为数组是有序的, 逻辑上是队列, 先绑定先触发
     * */
    // 如果有就放入, 没有就新建, 然后再看下是否有放入函数,没有就加入
    let fns = (this._cache[eventName] = this._cache[eventName] || []);
    // 如果事件方法没有的话就放入到字典进去
    if (fns.indexOf(callback === -1)) {
      fns.push(callback);
    }
    return this;
  }
  // 触发事件
  trigger(eventName, data) {
    // 看下字典里有没有这个函数名字， 有的话就触发它
    let fns = this._cache[eventName];
    if (Array.isArray(fns)) {
      // 有的话就对立面的每一个function传入参数data
      fns.forEach(fn => {
        fn(data);
      });
    }
    return this;
  }
  /*解绑， 看下字典里如果有这个事件名字就去
   * 看下要删除什么
   * */
  off(eventName, callback) {
    let fns = this._cache[eventName];
    if (Array.isArray(fns)) {
      if (callback) {
        let index = fns.indexOf(callback);
        if (index !== -1) {
          fns.splice(index, 1);
        }
      } else {
        // 全部清空
        fns.length = 0;
      }
    }
    return this;
  }
}
const event = new Event();
event.on("test", a => {
  console.log(a);
});
event.trigger("thet", "hello world"); // 绑定后就输出

event.off("test");
event.trigger("test", "hello world"); // 解绑后就不显示了

```
### 9.	手写去重函数

```js
  const arr = [1, '1', '1', 'NaN',NaN,'NaN', {a: 1}, '{a: 1}', {a: 1}]

 ```
 ```js
// 利用for嵌套for，然后splice去重（ES5中最常用）
 function unique2(arr) {
    for (var i = 0; i < arr.length; i++) {
      for (var j = i + 1; j < arr.length; j++) {
        if (arr[i] == arr[j]) {         //第一个等同于第二个，splice方法删除第二个
          arr.splice(j, 1);
          j--;
        }
      }
    }
    return arr;
  }

   // 利用hasOwnProperty
   function unique7(arr) {
    var obj = {};
    return arr.filter(function (item, index, arr) {
      return obj.hasOwnProperty(typeof item + item) ? false : (obj[typeof item + item] = true)
    })
  }


 // 利用filter
 function unique4(arr) {
    return arr.filter(function (item, index, arr) {
      //当前元素，在原始数组中的第一个索引==当前索引值，否则返回当前元素
      return arr.indexOf(item, 0) === index;
    });
  }
 ```
### 10.	mixin	/ 自定义指令/ v-if/	v-ssd/ diff算法

## 个人准备

> 手写ajax
```js
// 手写ajax
function get(){  
  var req = new XMLHTTPRequest();  
  if(req){  
      req.open("GET", "http://test.com/?keywords=手机", true);  
      req.onreadystatechange = function(){  
          if(req.readyState == 4){  
              if(req.status == 200){  
                  alert("success");  
              }else{  
                  alert("error");  
              }  
          }  
      }  
      req.send();  
  }  
}

```
> 事件绑定函数+事件委托
```js
function delegate(element, eeventType, selector, fn) {
  element.addEventListener(eventType, e => {
    let el = e.target
  })
}

```

> Promise实例
```js
// Promise
function fn(){ 
  var promise = new Promise(function(resolve,reject){
    // ... some code
    if(/*异步操作成功*/) {
    resolve(value) // 成功调用resolve 往下传递参数 且只接受一个参数
    }else {
    reject(error)  // 失败调用reject  往下传递参数 且只接受一个参数
    }   
  });
  return promise
}

fn.then(function (r) {
  console.log('成功: ' + r);
}).catch(function (reason) {
  console.log('失败: ' + reason);
});
// 全部成功调用
Promise.all([promise1,promise2]).then(sucess1,fail1)
// 有一个成功就调用
Promise.race([promise1,promise2]).then(sucess1,fail1)
```
> 自己实现Promise

- [必须要会的手写Promise](https://juejin.im/post/5ea39ea251882573b86fadbe)

```js
class MyPromise{
    constructor(executor) {
        this.status = "pending";     // 初始化状态为pending
        this.value = undefined;      // 初始化返回的成功的结果或者失败的原因
        
        // 这里是resolve方法，成功后执行，将状态改变为resolved，并且将结果返回
        let resolve = result => {
            if(this.status !== "pending") return;  // 状态一旦改变，就不会再变
            this.status = "resolved";
            this.value = result;
        }
        
        // 这里是reject方法，异常时执行，状态改为rejected，并且将失败的原因返回
        let reject = reason => {
            if(this.status !== "pending") return;
            this.status = "rejected";
            this.value = reason;
        }
        // try、catch捕获异常，如果错误，执行reject方法
        try {
            executor(resolve, reject)
        } catch(err) {
            reject(err)
        }
    }
}

// 作者：小小晴_
// 链接：https://juejin.im/post/5ea39ea251882573b86fadbe
// 来源：掘金
// 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

```
> vueX的原理和使用

- [Vuex的基本原理与使用](https://www.cnblogs.com/ysx215/p/11447042.html)

- [对于vuex原理的简单理解](https://www.jianshu.com/p/6e45e6814d1c)

> vue权限路由实现方式

- [vue权限路由实现方式总结](https://www.jianshu.com/p/bf4cda6b515f)

> 判断对象和数组
  
- > js 中的new()到底做了什么?

- [完全搞懂js 中的new()到底做了什么?][(https://www.jianshu.com/p/bf4cda6b515f](https://blog.csdn.net/qq_27674439/article/details/99095336))
 
**后记：Hello 小伙伴们，如果觉得本文还不错，记得点个赞或者给个 star，你们的赞和 star 是我编写更多更丰富文章的动力！[GitHub 地址](https://github.com/danygitgit/document-library)**

# 文档协议 
> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="知识共享许可协议" style="border-width:0" src="https://user-gold-cdn.xitu.io/2020/2/2/17001b902951cd22?imageslim" /></a><br /><a xmlns:dct="http://purl.org/dc/terms/" property="dct:title">**db** 的文档库</a> 由 <a xmlns:cc="http://creativecommons.org/ns#" href="db" property="cc:attributionName" rel="cc:attributionURL">db</a> 采用 <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议</a>进行许可。<br />基于<a xmlns:dct="http://purl.org/dc/terms/" href="https://github.com/danygitgit" rel="dct:source">https://github.com/danygitgit</a>上的作品创作。<br />本许可协议授权之外的使用权限可以从 <a xmlns:cc="http://creativecommons.org/ns#" href="https://creativecommons.org/licenses/by-nc-sa/2.5/cn/" rel="cc:morePermissions">https://creativecommons.org/licenses/by-nc-sa/2.5/cn/</a> 处获得。

